{"version":3,"sources":["authorization.js"],"names":["OAUTH2_CSRF_TOKEN","Authorization","extend","derived","isAuthenticating","deps","fn","isAuthorizing","session","default","type","ready","namespace","initialize","attrs","options","ret","prototype","parse","location","spark","getWindow","href","_checkForErrors","hash","includes","substr","state","JSON","decode","tokenData","_parseHash","_cleanUrl","process","nextTick","credentials","set","supertoken","initiateLogin","csrf_token","_generateSecurityToken","config","clientType","initiateAuthorizationCodeGrant","initiateImplicitGrant","logger","info","buildLoginUrl","response_type","resolve","logout","noRedirect","buildLogoutUrl","query","error","ErrorConstructor","select","history","replaceState","forEach","key","encode","stringify","format","token","v4","sessionStorage","setItem","_verifySecurityToken","access_token","undefined","expires_in","parseInt","refresh_token_expires_in","sessionToken","getItem","removeItem","Error"],"mappings":"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","file":"authorization.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n * @ignore\n */\n\n/* eslint camelcase: [0] */\n\nimport querystring from 'querystring';\nimport url from 'url';\nimport {base64, whileInFlight} from '@ciscospark/common';\nimport {grantErrors, SparkPlugin} from '@ciscospark/spark-core';\nimport {cloneDeep, omit} from 'lodash';\nimport uuid from 'uuid';\n\nconst OAUTH2_CSRF_TOKEN = `oauth2-csrf-token`;\n\n/**\n * Browser support for OAuth2. Automatically parses the URL hash for an access\n * token\n * @class\n * @variation 3\n */\nconst Authorization = SparkPlugin.extend({\n  derived: {\n    /**\n     * Alias of {@link Authorization(3)#isAuthorizing}\n     * @instance\n     * @memberof Authorization(3)\n     * @type {boolean}\n     */\n    isAuthenticating: {\n      deps: [`isAuthorizing`],\n      fn() {\n        return this.isAuthorizing;\n      }\n    }\n  },\n\n  session: {\n    /**\n     * Indicates if an Authorization Code exchange is inflight\n     * @instance\n     * @memberof Authorization(3)\n     * @type {boolean}\n     */\n    isAuthorizing: {\n      default: false,\n      type: `boolean`\n    },\n    ready: {\n      default: false,\n      type: `boolean`\n    }\n  },\n\n  namespace: `Credentials`,\n\n  /**\n   * Initializer\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} attrs {@link AmpersandState}\n   * @param {boolean} attrs.parse Controls whether or not the the url should get\n   * parsed for an access token\n   * @private\n   * @returns {Authorization}\n   */\n   // eslint-disable-next-line complexity\n  initialize(attrs, options) {\n    const ret = Reflect.apply(SparkPlugin.prototype.initialize, this, [attrs, options]);\n    // Reminder, we can't do parse based on config, because config is not\n    // available until nextTick and we want to be able to throw errors found in\n    // the url.\n    if (attrs.parse === false) {\n      this.ready = true;\n      return ret;\n    }\n    const location = url.parse(this.spark.getWindow().location.href, true);\n    this._checkForErrors(location);\n\n    let hash = location.hash;\n    if (!hash) {\n      this.ready = true;\n      return ret;\n    }\n    if (hash.includes(`#`)) {\n      hash = hash.substr(1);\n    }\n    location.hash = querystring.parse(hash);\n    if (location.hash.state) {\n      location.hash.state = JSON.parse(base64.decode(location.hash.state));\n    }\n    const tokenData = this._parseHash(location);\n    if (!tokenData) {\n      return ret;\n    }\n    this._cleanUrl(location);\n\n    // Wait until nextTick in case `credentials` hasn't initialized yet\n    process.nextTick(() => {\n      this.spark.credentials.set({supertoken: tokenData});\n      this.ready = true;\n    });\n\n    return ret;\n  },\n\n  /**\n   * Kicks off an oauth flow\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateLogin(options = {}) {\n    options.state = options.state || {};\n    options.state.csrf_token = this._generateSecurityToken();\n\n    // If we're not explicitly a confidential client, assume we're a public\n    // client\n    if (this.config.clientType === `confidential`) {\n      return this.initiateAuthorizationCodeGrant(options);\n    }\n\n    return this.initiateImplicitGrant(options);\n  },\n\n  @whileInFlight(`isAuthorizing`)\n  /**\n   * Kicks off the Authorization Code grant flow. Typically called via\n   * {@link Authorization(3)#initiateLogin}\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateImplicitGrant(options) {\n    this.logger.info(`authorization: initiating implicit grant flow`);\n    this.spark.getWindow().location = this.spark.credentials.buildLoginUrl(Object.assign({response_type: `token`}, options));\n    return Promise.resolve();\n  },\n\n  @whileInFlight(`isAuthorizing`)\n  /**\n   * Kicks off the Implicit Code grant flow. Typically called via\n   * {@link Authorization(3)#initiateLogin}\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} options\n   * @returns {Promise}\n   */\n  initiateAuthorizationCodeGrant(options) {\n    this.logger.info(`authorization: initiating authorization code grant flow`);\n    this.spark.getWindow().location = this.spark.credentials.buildLoginUrl(Object.assign({response_type: `code`}, options));\n    return Promise.resolve();\n  },\n\n  /**\n   * Called by {@link SparkCore#logout()}. Redirects to the logout page\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} options\n   * @param {boolean} options.noRedirect if true, does not redirect\n   * @returns {Promise}\n   */\n  logout(options = {}) {\n    if (!options.noRedirect) {\n      this.spark.getWindow().location = this.spark.credentials.buildLogoutUrl(options);\n    }\n  },\n\n  /**\n   * Checks if the result of the login redirect contains an error string\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _checkForErrors(location) {\n    const query = location.query;\n    if (query && query.error) {\n      const ErrorConstructor = grantErrors.select(query.error);\n      throw new ErrorConstructor(query);\n    }\n  },\n\n  /**\n   * Removes no-longer needed values from the url (access token, csrf token, etc)\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} location\n   * @private\n   * @returns {Promise}\n   */\n  _cleanUrl(location) {\n    location = cloneDeep(location);\n    if (this.spark.getWindow().history && this.spark.getWindow().history.replaceState) {\n      [\n        `access_token`,\n        `token_type`,\n        `expires_in`,\n        `refresh_token`,\n        `refresh_token_expires_in`\n      ].forEach((key) => Reflect.deleteProperty(location.hash, key));\n      location.hash.state = base64.encode(JSON.stringify(omit(location.hash.state, `csrf_token`)));\n      location.hash = querystring.stringify(location.hash);\n      this.spark.getWindow().history.replaceState({}, null, url.format(location));\n    }\n  },\n\n  /**\n   * Generates a CSRF token and sticks in in sessionStorage\n   * @instance\n   * @memberof Authorization(3)\n   * @private\n   * @returns {Promise}\n   */\n  _generateSecurityToken() {\n    this.logger.info(`authorization: generating csrf token`);\n\n    const token = uuid.v4();\n    this.spark.getWindow().sessionStorage.setItem(`oauth2-csrf-token`, token);\n    return token;\n  },\n\n  /**\n   * Parses the url hash into an access token object\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} location\n   * @private\n   * @returns {Object}\n   */\n  _parseHash(location) {\n    const hash = cloneDeep(location.hash);\n    if (hash) {\n      this._verifySecurityToken(hash);\n    }\n    if (!hash.access_token) {\n      this.ready = true;\n      return undefined;\n    }\n    if (hash.expires_in) {\n      hash.expires_in = parseInt(hash.expires_in, 10);\n    }\n    if (hash.refresh_token_expires_in) {\n      hash.refresh_token_expires_in = parseInt(hash.refresh_token_expires_in, 10);\n    }\n    return hash;\n  },\n\n  /**\n   * Checks if the CSRF token in sessionStorage is the same as the one returned\n   * in the url.\n   * @instance\n   * @memberof Authorization(3)\n   * @param {Object} hash\n   * @private\n   * @returns {Promise}\n   */\n  _verifySecurityToken(hash) {\n    const sessionToken = this.spark.getWindow().sessionStorage.getItem(OAUTH2_CSRF_TOKEN);\n    this.spark.getWindow().sessionStorage.removeItem(OAUTH2_CSRF_TOKEN);\n    if (!sessionToken) {\n      return;\n    }\n\n    if (!hash.state) {\n      throw new Error(`Expected CSRF token ${sessionToken}, but not found in redirect hash`);\n    }\n\n    if (!hash.state.csrf_token) {\n      throw new Error(`Expected CSRF token ${sessionToken}, but not found in redirect hash`);\n    }\n\n    const token = hash.state.csrf_token;\n\n    if (token !== sessionToken) {\n      throw new Error(`CSRF token ${token} does not match stored token ${sessionToken}`);\n    }\n  }\n});\n\nexport default Authorization;\n"]}